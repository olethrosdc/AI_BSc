#+TITLE: Constrained Problems
#+AUTHOR: Christos Dimitrakakis
#+EMAIL:christos.dimitrakakis@unine.ch
#+LaTeX_HEADER: \usepackage{algorithm,algorithmic}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{isomath}
#+LaTeX_HEADER: \newcommand \E {\mathop{\mbox{\ensuremath{\mathbb{E}}}}\nolimits}
#+LaTeX_HEADER: \newcommand \Var {\mathop{\mbox{\ensuremath{\mathbb{V}}}}\nolimits}
#+LaTeX_HEADER: \newcommand \Bias {\mathop{\mbox{\ensuremath{\mathbb{B}}}}\nolimits}
#+LaTeX_HEADER: \newcommand\ind[1]{\mathop{\mbox{\ensuremath{\mathbb{I}}}}\left\{#1\right\}}
#+LaTeX_HEADER: \renewcommand \Pr {\mathop{\mbox{\ensuremath{\mathbb{P}}}}\nolimits}
#+LaTeX_HEADER: \DeclareMathOperator*{\argmax}{arg\,max}
#+LaTeX_HEADER: \DeclareMathOperator*{\argmin}{arg\,min}
#+LaTeX_HEADER: \DeclareMathOperator*{\sgn}{sgn}
#+LaTeX_HEADER: \newcommand \defn {\mathrel{\triangleq}}
#+LaTeX_HEADER: \newcommand \Reals {\mathbb{R}}
#+LaTeX_HEADER: \newcommand \Param {\Theta}
#+LaTeX_HEADER: \newcommand \param {\theta}
#+LaTeX_HEADER: \newcommand \vparam {\vectorsym{\theta}}
#+LaTeX_HEADER: \newcommand \mparam {\matrixsym{\Theta}}
#+LaTeX_HEADER: \newcommand \bW {\matrixsym{W}}
#+LaTeX_HEADER: \newcommand \bw {\vectorsym{w}}
#+LaTeX_HEADER: \newcommand \wi {\vectorsym{w}_i}
#+LaTeX_HEADER: \newcommand \wij {w_{i,j}}
#+LaTeX_HEADER: \newcommand \bA {\matrixsym{A}}
#+LaTeX_HEADER: \newcommand \ai {\vectorsym{a}_i}
#+LaTeX_HEADER: \newcommand \aij {a_{i,j}}
#+LaTeX_HEADER: \newcommand \bx {\vectorsym{x}}
#+LaTeX_HEADER: \newcommand \callcset[2] {\left\{#1 ~\middle|~ #2 \right\}}
#+LaTeX_HEADER: \newcommand \pol {\pi}
#+LaTeX_HEADER: \newcommand \Pols {\Pi}
#+LaTeX_HEADER: \newcommand \mdp {\mu}
#+LaTeX_HEADER: \newcommand \MDPs {\mathcal{M}}
#+LaTeX_HEADER: \newcommand \bel {\beta}
#+LaTeX_HEADER: \newcommand \Bels {\mathcal{B}}
#+LaTeX_HEADER: \newcommand \Unif {\textrm{Unif}}
#+LaTeX_HEADER: \newcommand \Ber {\textrm{Bernoulli}}
#+LaTeX_HEADER: \newcommand \Mult {\textrm{Mult}}
#+LaTeX_HEADER: \newcommand \Beta {\textrm{Beta}}
#+LaTeX_HEADER: \newcommand \Dir {\textrm{Dir}}
#+LaTeX_HEADER: \newcommand \Normal {\textrm{Normal}}
#+LaTeX_HEADER: \newcommand \Simplex {\mathbb{\Delta}}
#+LaTeX_HEADER: \newcommand \pn {\param^{(n)}}
#+LaTeX_HEADER: \newcommand \pnn {\param^{(n+1)}}
#+LaTeX_HEADER: \newcommand \pnp {\param^{(n-1)}}
#+LaTeX_HEADER: \usetikzlibrary{shapes.geometric}
#+LaTeX_HEADER: \usetikzlibrary{arrows.meta, positioning, quotes}
#+LaTeX_HEADER: \tikzstyle{utility}=[diamond,draw=black,draw=blue!50,fill=blue!10,inner sep=0mm, minimum size=8mm]
#+LaTeX_HEADER: \tikzstyle{select}=[rectangle,draw=black,draw=blue!50,fill=blue!10,inner sep=0mm, minimum size=6mm]
#+LaTeX_HEADER: \tikzstyle{hidden}=[dashed,draw=black,fill=red!10]
#+LaTeX_HEADER: \tikzstyle{RV}=[circle,draw=black,draw=blue!50,fill=blue!10,inner sep=0mm, minimum size=6mm]
#+LaTeX_CLASS_OPTIONS: [smaller]
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+TAGS: activity advanced definition exercise homework project example theory code
#+OPTIONS:   H:3
* Introduction
** General optimisation problems
*** Optimisation on graphs
**** Discrete optimisation
- Shortest path.
- Meeting scheduling.
- Travelling salesman.
- Graph colouring.
- Bipartite matching.
- Spanning trees.
**** Continuous optimisation
- Maximum flow: inequality constraints
- Minimum-cost flow: equality constraints.
**** Complexity
- Currently $\tilde{O}(N^{2/3})$.
- $Ax = b$ can be solved in approximately linear time. (Spielman-Teng)
** Example problems

*** Meeting Scheduling
- Graph $G = (N, E)$, $s, t \in N$ being the source and sink.
- Edge capacity $c : E \to \Reals_+$
**** Flow $f : E \to \Reals$
The total flow from source to sink is
\[|f| = \sum_{(s,i) \in E} f_{si}  = \sum_{(j,t) \in E} f_{jt}\]
**** Flow constraints
The flow satisfies the following constraints:
- Capacity constraint: $f_{ij} \leq c_{ij}$
- Conservation of flows:
\[
\forall n \in N \setminus \{s, t\}  
\sum_{i : (i,j) \in E, f_{ij} > 0} f_ij
=
\sum_{j : (i,j) \in E, f_{ji} > 0} f_ji.
\]
**** The maximum network flow problem
Maximise $|f|$ while satisfying the capacity and conservation constraints.
* Constraint optimisation
** Constraint Satisfaction
*** Constrained Satisfaction Problems
**** Variables
- A set of variables $\{x_1, \ldots, x_n\}$
- Each variable can take values in $x \in X_i$.
**** Binary constraints
- $c_{i,j} : X_i \times X_j \to \{0, 1\}$.
**** Graph representation
\begin{tikzpicture}[every edge quotes/.style = {auto, font=\footnotesize, sloped}]
      \node[RV] at (0,0) (1) {$x_1$};
      \node[RV] at (0,2) (2) {$x_2$};
      \node[RV] at (4,2) (3) {$x_3$};
      \node[RV] at (4,0) (4) {$x_4$};
      \draw[->] (1) edge["$x_1 = x_2$"] (2);
      \draw[->] (2) edge["$x_2 \geq x_3$"] (3);
      \draw[->] (3) edge["$x_3 \neq x_4$"] (4);
      \draw[->] (4) edge["$c=c_j$"] (1);
\end{tikzpicture}
- Goal: Find $x \in \prod_i X_i$ so that $c = 1$.
** Constrained Optimisation Problems 
*** Constrained optimisation Problems
**** Variables
- A set of variables $\{x_1, \ldots, x_n\}$
- Each variable can take values in $x \in X_i$, with $X \in \prod_i X_i$.
**** Pairwise constraints
- $c_{i,j} : X_i \times X_j \to \{0, 1\}$.
**** Objective function
- Maximise $u: X \to \Reals$.
**** Special cases:
- $u(X) = \sum_i u_i(x_i)$
- $u(X) = \sum_{ij} u_{ij}(x_i, x_j)$
*** Network Flow
- Graph $G = (N, E)$, $s, t \in N$ being the source and sink.
- Edge capacity $c : E \to \Reals_+$
**** Flow $f : E \to \Reals$
The total flow from source to sink is
\[|f| = \sum_{(s,i) \in E} f_{si}  = \sum_{(j,t) \in E} f_{jt}\]
**** Flow constraints
The flow satisfies the following constraints:
- Capacity constraint: $f_{ij} \leq c_{ij}$
- Conservation of flows:
\[
\forall n \in N \setminus \{s, t\}  
\sum_{i : (i,j) \in E, f_{ij} > 0} f_ij
=
\sum_{j : (i,j) \in E, f_{ji} > 0} f_ji.
\]
**** The maximum network flow problem
Maximise $|f|$ while satisfying the capacity and conservation constraints.

* Logical constraints
** Logic 
*** Logic
**** Statements
- A statement $A$ may be true or false

**** Unary operators
- negation: $\neg A$ is true if $A$ is false (and vice-versa).

**** Binary operators
- or: $A \vee B$ ($A$ or $B$) is true if either $A$ or $B$ are true.
- and: $A \wedge B$ is true if both $A$ and $B$ are true.
- implies: $A \Rightarrow B$: is false if $A$ is true and $B$ is false.
- iff: $A \Leftrightarrow B$: is true if $A,B$ have equal truth values.

**** Operator precedence
$\neg, \wedge, \vee, \Rightarrow, \Leftrightarrow$

*** Set theory
- First, consider some universal set $\Omega$.
- A set $A$ is a collection of points $x$ in $\Omega$.
- $\{x \in \Omega : f(x)\}$: the set of points in $\Omega$ with the property that $f(x)$ is true.

**** Unary operators
- $\neg A =  \{x \in \Omega : x \notin A\}$.
**** Binary operators
- $A \cup B$ if $\{x \in \Omega : x \in A \vee x \in B\}$ - (c.f. $A \vee B$)
- $A \cap B$ if $\{x \in \Omega : x \in A \wedge x \in B\}$ - (c.f. $A \wedge B$)
**** Binary relations
- $A \subset B$ if $x \in A \Rightarrow x \in B$ - (c.f. $A \implies B$)
- $A = B$ if $x \in A \Leftrightarrow x \in B$ - (c.f. $A \Leftrightarrow B$)

*** Knowledge base
**** Syntax and Semtantics
- Syntax: How to construct sentences
- Semantix: What sentences mean
**** Truth
- A statement $A$ is either true or false in any model $m$.
**** Model
- $M(A)$ the set of all models where $A$ is true.
**** Entailment
- $A \models B$ means that $B$ is true whenever $A$ is true.
- $A \models B$ if and only if $M(A) \subseteq M(B)$.
**** Knowledge-Base
- A set of sentences that are true.
**** Inference
- $KB \vdash_i A$: Algorithm $i$ can derive $A$ from KB.
*** Propositional logic syntax
-Sentence $\to$ Atomic | Complex
-Atomic \to True | False | A | B | C | \ldots
-Complex \to (Sentence) | [Sentence]
- | $\neg$  Sentence (not)
- | Sentence $\wedge$ Sentence (and)
- | Sentence $\vee$ Sentence (or)
- | Sentence $\Rightarrow$ Sentence (implies)
- | Sentence $\Leftrightarrow$ Sentence (if and only if)

Precedence: $\neg, \wedge, \vee, \Rightarrow, \Leftrightarrow$

*** Set theory semantics of propositional logic
**** Atoms as sets 
- Let $\Omega$ be the universal set.
- Any atom $A$ is a subset of $\Omega$.
- Any model $\omega$ is an element of $\Omega$.
**** Definitions
- $A \Rightarrow B$ is equivalent to $A \supset B$.
- $\neg (\neg A) \equiv A$
- $(A \Rightarrow B) \equiv (\neg B \Rightarrow \neg A)$
- $(A \Rightarrow B) \equiv (\neg A \vee B)$

**** For any model $m$:
- $\neg P$ is true iff $P$ is false in $m$.
- $P \wedge Q$ is true iff $P, Q$ are true in $m$.
- $P \vee Q$ is true iff either $P$ or $Q$ is true in $m$.
- $P \Rightarrow Q$ is true unless $P$ is true and $Q$ is false in $m$.
- $P \Leftrightarrow Q$ if $P,Q$ are both true or both false in $m$.


- If $A \subset B$ then, for every $\omega \in A$,  $\omega \in B$.
- If $\omega \in A \cap B$ then $\omega \in A$.

** Deterministic planning
*** [[https://artint.info/3e/html/ArtInt3e.Ch6.S1.html][States, actions and goals]]
- States $s \in S$
- Actions $a \in A$
- Transition function $\tau : S \times A \to S$
*** State representation
